using System;
using System.Collections.Generic;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using System.Xml;
using static TibiantisHelper.Utility;

namespace TibiantisHelper
{
    public class DataReader
    {

        // Thanks to https://github.com/TibiaJS/sprites-extractor for providing a neat way of reading sprite file format
        // Thanks to https://github.com/nekiro/7.72-dat-editor for data file format

        public static string spriteFile = @"Tibiantis.spr";
        public static string dataFile = @"Tibiantis.dat";

        public static string locationsFile = @"data\dat\map.dat";
        public static string itemFile = @"data\dat\objects.srv";

        public static string lookupFile = @"Lookup.dat"; // Generated by this program to store data file addresses so we don't have to keep in memory

        public static string npcFolder = @"data\npc";
        public static string monsterFolder = @"data\mon";

        public static string runeFile = @"data\Runes.xml";
        public static string spellFile = @"data\Spells.xml";
        public static string vialFile = @"data\Vials.xml";

        private uint maxClientId;

        private uint datLookTypes;
        private uint datEffects;
        private uint datMissiles;

        public List<Location> locations;
        public List<NPC> npcs;
        public List<Item> items;
        public List<Monster> monsters;
        public static List<Raid> raids;
        public List<Rune> runes;
        public List<Spell> spells;

        public DataReader()
        {

            if (!File.Exists(spriteFile) || !File.Exists(dataFile))
            {
                String missingStr = $"Missing {spriteFile} and/or {dataFile}!{Environment.NewLine}{Environment.NewLine}" +
                    $"This program does not come with either of these, so you must provide them yourself. {Environment.NewLine}{Environment.NewLine}" +
                    "Press OK to browse for the missing files, or press Cancel if you want to move them manually to this folder.";

                switch (MessageBox.Show(missingStr, "Missing files", MessageBoxButtons.OKCancel, MessageBoxIcon.Error))
                {
                    case DialogResult.OK:
                        if (!File.Exists(spriteFile))
                            BrowseForFile("Sprite File |Tibiantis.spr", spriteFile);

                        if (!File.Exists(dataFile))
                            BrowseForFile("Data File |Tibiantis.dat", dataFile);
                        break;
                    case DialogResult.Cancel:
                        Environment.Exit(0);
                        break;
                }
            }


            GenerateLookup();

            locations = ParseLocations();
            npcs = ParseNPC();
            items = ParseItems();
            monsters = ParseMonsters();
            raids = ParseRaids();
            runes = ParseRunes();
            spells = ParseSpells();
        }

        private void BrowseForFile(string filter, string file)
        {
            var ext = Path.GetExtension(file);
            var simple = Path.GetFileName(file);

            var diag = new OpenFileDialog();
            diag.RestoreDirectory = true;

            diag.Filter = filter;

            if (diag.ShowDialog() == DialogResult.OK)
            {
                File.Copy(diag.FileName, simple);
            } else
            {
                Environment.Exit(0);
            }
        }

        #region Locations


        public struct Location
        {
            public string Name;
            public Point3D Position;
        }
        public List<Location> ParseLocations()
        {
            List<Location> locList = new List<Location>();

            using (System.IO.StreamReader file = new System.IO.StreamReader(locationsFile))
            {

                string line = "";

                while ((line = file.ReadLine()) != null)
                {

                    string[] split = line.Split(' ');

                    if (split[0] == "Mark")
                    {
                        var secondPart = GetBetweenChars(line, '(', ')');

                        var locName = GetBetweenChars(secondPart, '"', '"');
                        var xyz = GetBetweenChars(secondPart, '[', ']');

                        var xyzSplit = xyz.Split(',');

                        int x = int.Parse(xyzSplit[0]);
                        int y = int.Parse(xyzSplit[1]);
                        int z = int.Parse(xyzSplit[2]);

                        Location loc;

                        loc.Name = locName;
                        loc.Position = new Point3D(x, y, z);

                        locList.Add(loc);


                    }

                }

            }


            return locList;
        }

        public struct Point3D
        {
            public int X;
            public int Y;
            public int Z;

            public Point3D(int x, int y, int z)
            {
                this.X = x;
                this.Y = y;
                this.Z = z;
            }
        }

        #endregion



        #region Entity

        public Entity ReadEntity(int entityID)
        {

            if (entityID < 100) return null;

            Entity entity = new Entity((uint)entityID);

            try
            {

                uint itemOffset;

                using (BinaryReader reader = new BinaryReader(File.Open(lookupFile, FileMode.Open)))
                {
                    reader.BaseStream.Seek(entityID * 4, SeekOrigin.Begin);
                    itemOffset = reader.ReadUInt32();
                }

                using (BinaryReader reader = new BinaryReader(File.Open(dataFile, FileMode.Open)))
                {
                    var datSignature = reader.ReadUInt32();
                    uint maxClientId = reader.ReadUInt16();
                    datLookTypes = reader.ReadUInt16();
                    datEffects = reader.ReadUInt16();
                    datMissiles = reader.ReadUInt16();

                    byte flag;

                    reader.BaseStream.Seek(itemOffset, SeekOrigin.Begin);

                    do
                    {
                        flag = reader.ReadByte();
                        switch (flag)
                        {
                            case 0x00: // ground
                                entity.ground = true;
                                entity.groundSpeed = reader.ReadUInt16(); // ground speed
                                break;
                            case 0x01: // clip
                                entity.clip = true;
                                break;
                            case 0x02: // bottom
                                entity.bottom = true;
                                break;
                            case 0x03: // top
                                entity.top = true;
                                break;
                            case 0x04: // container
                                entity.container = true;
                                break;
                            case 0x05: // stackable
                                entity.stackable = true;
                                break;
                            case 0x06: // corpse (force use)
                                entity.corpse = true;
                                break;
                            case 0x07: // usable
                                entity.usable = true;
                                break;
                            case 0x08: // writable
                                entity.writable = true;
                                entity.writableLenght = reader.ReadUInt16(); // maxTextLenght
                                break;
                            case 0x09: // readable
                                entity.readable = true;
                                entity.readableLenght = reader.ReadUInt16(); // maxTextLenght
                                break;
                            case 0x0A: // fluid container
                                entity.fluid = true;
                                break;
                            case 0x0B: // splash
                                entity.splash = true;
                                break;
                            case 0x0C: // blocking
                                entity.blocking = true;
                                break;
                            case 0x0D: // not movable
                                entity.immovable = true;
                                break;
                            case 0x0E: // blocks missile
                                entity.blocksMissile = true;
                                break;
                            case 0x0F: // blocks path
                                entity.blocksPath = true;
                                break;
                            case 0x10: // pickupable
                                entity.pickupable = true;
                                break;
                            case 0x11: // hangable
                                entity.hangable = true;
                                break;
                            case 0x12: // horizontal
                                entity.horizontal = true;
                                break;
                            case 0x13: // vertical
                                entity.vertical = true;
                                break;
                            case 0x14: // rotatable
                                entity.rotatable = true;
                                break;

                            case 0x15: // light info
                                entity.hasLight = true;
                                entity.lightLevel = reader.ReadUInt16(); // light level
                                entity.lightColor = reader.ReadUInt16(); // light color
                                break;
                            case 0x16: // don't hide
                                entity.dontHide = true;
                                break;
                            case 0x17: // translucent
                                entity.floorchange = true;
                                break;
                            case 0x18: // offset
                                entity.hasOffset = true;
                                entity.offsetX = reader.ReadUInt16(); // X
                                entity.offsetY = reader.ReadUInt16(); // Y
                                break;
                            case 0x19: // height (elevation)
                                entity.hasHeight = true;
                                entity.height = reader.ReadUInt16(); // height
                                break;
                            case 0x1A: // lying object
                                entity.layer = true;
                                break;
                            case 0x1B: // idle animated
                                entity.idleAnimated = true;
                                break;
                            case 0x1C: // minimap
                                entity.minimap = true;
                                entity.minimapColor = reader.ReadUInt16(); // color
                                break;
                            case 0x1D: // actions
                                entity.actioned = true;
                                entity.actions = reader.ReadUInt16();
                                break;
                            case 0x1E: // full ground
                                entity.groundItem = true;
                                break;
                            case 0xFF: // end of flags
                                break;
                            default:
                                // MessageBox.Show("Unknown byte " + flag.ToString("X2"));
                                break;
                        }

                    } while (flag != 0xFF);

                    uint width = reader.ReadByte();
                    uint height = reader.ReadByte();
                    if (width > 1 || height > 1)
                    {
                        reader.ReadByte(); // skip byte
                    }

                    uint blendFrames = reader.ReadByte();
                    uint divX = reader.ReadByte();
                    uint divY = reader.ReadByte();
                    uint divZ = reader.ReadByte();
                    uint animations = reader.ReadByte();

                    uint sprites = (uint)width * height * blendFrames * divX * divY * divZ * animations;
                    for (int i = 0; i < sprites; i++)
                    {
                        entity.sprites.Add(reader.ReadUInt16()); //sprite id
                    }

                }
            }
            catch (Exception)
            {
                Console.WriteLine("Error?");
                return null;
            }

            return entity;

        }

        public void GenerateLookup()
        {
            try
            {
                using (BinaryReader reader = new BinaryReader(File.Open(dataFile, FileMode.Open)))
                {
                    using (BinaryWriter writer = new BinaryWriter(File.Create(lookupFile)))
                    {
                        reader.BaseStream.Seek(4, SeekOrigin.Current);
                        maxClientId = reader.ReadUInt16();
                        reader.BaseStream.Seek(6, SeekOrigin.Current);

                        byte flag;
                        uint id = 100;
                        uint offset;
                        while (id <= maxClientId)
                        {
                            offset = (uint)reader.BaseStream.Position;
                            writer.Write(offset);
                            do
                            {
                                flag = reader.ReadByte();
                                switch (flag)
                                {
                                    case 0x00:
                                        reader.BaseStream.Seek(2, SeekOrigin.Current);
                                        break;
                                    case 0x08:
                                        reader.BaseStream.Seek(2, SeekOrigin.Current);
                                        break;
                                    case 0x09:
                                        reader.BaseStream.Seek(2, SeekOrigin.Current);
                                        break;
                                    case 0x15:
                                        reader.BaseStream.Seek(4, SeekOrigin.Current);
                                        break;
                                    case 0x18:
                                        reader.BaseStream.Seek(4, SeekOrigin.Current);
                                        break;
                                    case 0x19:
                                        reader.BaseStream.Seek(2, SeekOrigin.Current);
                                        break;
                                    case 0x1C:
                                        reader.BaseStream.Seek(2, SeekOrigin.Current);
                                        break;
                                    case 0x1D:
                                        reader.BaseStream.Seek(2, SeekOrigin.Current);
                                        break;
                                    default:
                                        // MessageBox.Show("Unknown byte " + flag.ToString("X2"));
                                        break;
                                }

                            } while (flag != 0xFF);

                            uint width = reader.ReadByte();
                            uint height = reader.ReadByte();
                            if (width > 1 || height > 1)
                            {
                                reader.ReadByte();
                            }

                            uint blendFrames = reader.ReadByte();
                            uint divX = reader.ReadByte();
                            uint divY = reader.ReadByte();
                            uint divZ = reader.ReadByte();
                            uint animations = reader.ReadByte();

                            uint sprites = (uint)width * height * blendFrames * divX * divY * divZ * animations;
                            for (int i = 0; i < sprites; i++)
                            {
                                reader.BaseStream.Seek(2, SeekOrigin.Current);
                            }

                            ++id;
                        }
                    }

                }
            }
            catch (Exception)
            {
                Console.WriteLine("Error");
            }
        }

        public class Entity
        {
            public List<int> sprites;

            public uint id;
            public bool ground;
            public uint groundSpeed;
            public bool clip;
            public bool top;
            public bool bottom;
            public bool container;
            public bool stackable;
            public bool corpse;
            public bool usable;
            public bool writable;
            public uint writableLenght;
            public bool readable;
            public uint readableLenght;
            public bool fluid;
            public bool splash;
            public bool blocking;
            public bool immovable;
            public bool blocksMissile;
            public bool blocksPath;
            public bool pickupable;
            public bool hangable;
            public bool vertical;
            public bool horizontal;
            public bool rotatable;
            public bool hasLight;
            public uint lightLevel;
            public uint lightColor;
            public bool floorchange;
            public bool hasOffset;
            public bool dontHide;
            public uint offsetX;
            public uint offsetY;
            public bool hasHeight;
            public uint height;
            public bool layer;
            public bool idleAnimated;
            public bool minimap;
            public uint minimapColor;
            public bool actioned;
            public uint actions;
            //actions?
            public bool groundItem;

            public Entity(uint id)
            {
                this.id = id;
                this.sprites = new List<int>();
            }
        };

        #endregion

        #region Sprite

        public Bitmap ReadSprite(int spriteID)
        {

            Bitmap bmp = new Bitmap(32, 32);

            if (spriteID == 0) return bmp;

            using (BinaryReader reader = new BinaryReader(File.OpenRead(spriteFile), Encoding.ASCII))
            {

                uint signature = reader.ReadUInt32();
                ushort count = reader.ReadUInt16();

                // Console.WriteLine("Signature: " + signature);
                // Console.WriteLine("Count: " + count);

                var formula = 6 + (spriteID - 1) * 4;


                reader.BaseStream.Seek(formula, System.IO.SeekOrigin.Begin);

                var address = reader.ReadUInt32();

                if (address == 0)
                {
                    Console.WriteLine("Empty sprite");
                    return bmp;
                }

                reader.BaseStream.Seek(address, System.IO.SeekOrigin.Begin);

                // Skipping color key.
                reader.BaseStream.Seek(3, System.IO.SeekOrigin.Current);

                var endBitmap = reader.BaseStream.Position + reader.ReadUInt16();
                var startBitmap = reader.BaseStream.Position;


                //Console.WriteLine("Reading sprite " + spriteID + " at " + startBitmap + " - " + endBitmap);

                UInt32 currentPixel = 0;
                UInt32 size = 32;

                while (reader.BaseStream.Position < endBitmap)
                {
                    var transparentPixels = reader.ReadUInt16();
                    var coloredPixels = reader.ReadUInt16();
                    currentPixel += transparentPixels;

                    for (var i = 0; i < coloredPixels; i++)
                    {

                        bmp.SetPixel((int)currentPixel % (int)size, (int)currentPixel / (int)size,
                        Color.FromArgb(255, reader.ReadByte(), reader.ReadByte(), reader.ReadByte()));
                        currentPixel++;
                    }
                }

            }

            return bmp;
        }

        #endregion

        #region Minimap

        public async static Task<Bitmap> ReadMinimap(string file)
        {
            Bitmap map = new Bitmap(256, 256);

            using (BinaryReader reader = new BinaryReader(File.OpenRead(file), Encoding.ASCII))
            {
                for (int x = 0; x < 256; x++)
                {
                    for (int y = 0; y < 256; y++)
                    {
                        byte current = reader.ReadByte();


                        int R = 51 * (current / 36);
                        int G = 51 * ((current / 6) % 6);
                        int B = 51 * (current % 6);

                        if (R > 255) R = 0;
                        if (G > 255) G = 0;
                        if (B > 255) B = 0;

                        Color c = Color.FromArgb(R, G, B);


                        map.SetPixel(x, y, c);
                    }
                }
            }

            return map;
        }

        #endregion


        #region Rune

        public struct Rune
        {
            public short ID;
            public string Name;
            public byte Charges;

            public Rune(short ID, string Name, byte Charges)
            {
                this.ID = ID;
                this.Name = Name;
                this.Charges = Charges;
            }
        }

        private List<Rune> ParseRunes()
        {
            List<Rune> runes = new List<Rune>();

            XmlDocument doc = new XmlDocument();
            doc.Load(runeFile);

            foreach (XmlNode node in doc.DocumentElement.ChildNodes)
            {
                string text = node.InnerText; //or loop through its children as well
                Rune rune = new Rune();

                foreach (XmlNode value in node.ChildNodes)
                {
                    switch (value.Name)
                    {
                        case "ID":
                            rune.ID = short.Parse(value.InnerText);
                            break;
                        case "Name":
                            rune.Name = value.InnerText;
                            break;
                        case "Charges":
                            rune.Charges = byte.Parse(value.InnerText);
                            break;
                    }

                }
                runes.Add(rune);

            }

            runes = runes.OrderBy(r => r.Name).ToList();

            return runes;

        }

        #endregion

        #region Item


        private List<Item> ParseItems()
        {
            // Apparently they're "objects" and not "items" but I don't think C# would approve

            List<DataReader.Item> items = new List<DataReader.Item>();

            using (System.IO.StreamReader file = new System.IO.StreamReader(itemFile))
            {
                file.ReadLine();
                file.ReadLine();
                file.ReadLine();
                file.ReadLine();
                file.ReadLine();

                string dirtyString;
                DataReader.Item item = new DataReader.Item();
                while ((dirtyString = file.ReadLine()) != null)
                {

                    var line = System.Text.RegularExpressions.Regex.Replace(dirtyString, @"\s+", " ");

                    string[] split = line.Split(' ');

                    if (split.Length >= 2)
                    {

                        string first = split[0];
                        string second = split[2];


                        if (first == "TypeID")
                        {
                            // Process last item
                            if (item.Flags.Contains("Expire")) item.Name += " (Expiring)";

                            // Then start next one
                            item = new DataReader.Item();
                            items.Add(item);
                            item.ID = int.Parse(second);
                        }
                        else if (first == "Name")
                        {

                            item.Name = GetBetweenChars(line, '"', '"');

                            if (item.Name.Length > 2)
                            {
                                if (item.Name.Substring(0, 2) == "a ") item.Name = item.Name.Substring(2);
                                else if (item.Name.Substring(0, 3) == "an ") item.Name = item.Name.Substring(3);

                                item.Name = CapitalizeString(item.Name).TrimEnd();
                            }

                        }
                        else if (first == "Description")
                        {
                            item.Description = GetBetweenChars(line, '"', '"');
                        }
                        else if (first == "Flags")
                        {
                            string flagString = GetBetweenChars(line, '{', '}');
                            item.Flags.AddRange(flagString.Split(','));
                        }
                        else if (first == "Attributes")
                        {
                            string attributeString = GetBetweenChars(line, '{', '}');
                            var attributeList = attributeString.Split(',');

                            List<DataReader.Item.Attribute> attri = new List<DataReader.Item.Attribute>();

                            int i = 0;
                            foreach (var attribute in attributeList)
                            {
                                var attrSplit = attribute.Split('=');
                                DataReader.Item.Attribute a;
                                a.Name = attrSplit[0];
                                a.Value = int.Parse(attrSplit[1]);

                                attri.Add(a);

                                i++;
                            }

                            item.Attributes = attri;
                        }
                    }

                }

                return items.OrderBy(i => i.Name).ToList();
            }

        }


        public class Item
        {
            public struct Attribute
            {
                public string Name;
                public int Value;
            }

            public int ID;
            public string Name;
            public string Description;
            public List<string> Flags;
            public List<Attribute> Attributes;

            public Item()
            {
                Flags = new List<string>();
                Attributes = new List<Attribute>();

            }


            public int GetAttributeValue(string name)
            {
                int attr = 0;

                foreach (var a in Attributes)
                    if (a.Name == name)
                    {
                        attr = a.Value;
                        break;
                    }

                return attr;
            }

        }

        public List<Item> GetItemsByFilter(List<Item> source, string filter)
        {
            List<Item> items = new List<Item>();
            string[] filters = filter.Split(',');

            List<string> flags = new List<string>();
            List<string> attributes = new List<string>();

            foreach (var f in filters)
                if (f.Contains('=')) attributes.Add(f);
                else flags.Add(f);



            foreach (var i in source)
                if (i.ID > 99)
                {
                    bool hasFlags, hasAttributes;
                    hasFlags = hasAttributes = true;

                    foreach (var flag in flags)
                        if (!i.Flags.Contains(flag))
                            hasFlags = false;

                    foreach (var att in attributes)
                    {
                        bool attMatch = false;
                        foreach (var targetAtt in i.Attributes)
                        {
                            var splitAtt = att.Split('=');

                            if (targetAtt.Name == splitAtt[0])
                            {
                                if (splitAtt[1] == "*") attMatch = true;
                                else if (targetAtt.Value == int.Parse(splitAtt[1])) attMatch = true;
                            }
                        }
                        if (!attMatch) hasAttributes = false;
                    }

                    if (hasFlags && hasAttributes)
                        items.Add(i);
                }


            return items;
        }


        public List<Item> GetItemsByFlag(List<Item> source, string flag)
        {
            List<Item> items = new List<Item>();

            foreach (var i in source)
                if (i.ID > 99)
                    if (i.Flags.Contains(flag)) items.Add(i);

            return items;

        }

        public List<Item> GetItemsByAttribute(List<Item> source, string attribute, int value)
        {
            // If value is negative, just find every instance that has that attribute and ignore value

            List<Item> items = new List<Item>();
            Item.Attribute att;
            att.Name = attribute;
            att.Value = value;

            if (value < 0)
            {
                foreach (var i in source)
                    if (i.ID > 99)
                        foreach (var a in i.Attributes)
                            if (a.Name == attribute && attribute[0] != '!') items.Add(i);
            } else
            {
                foreach (var i in source)
                {
                    if (i.Attributes.Contains(att) && i.ID > 99 && attribute[0] != '!')
                        items.Add(i);
                }
            }



            return items;

        }

        #endregion

        #region Spell

        public struct Spell
        {
            public byte ID;
            public string Name;
            public string Words;
            public ushort Mana;
            public ushort ProduceID;
            public byte ProduceAmount;
            public byte LvlCast;
            public byte LvlUse;
            public ushort Price;
            public bool VocKnight;
            public bool VocPaladin;
            public bool VocSorcerer;
            public bool VocDruid;
            public byte Group;
            public byte Type;
            public bool Premium;
        }

        private List<Spell> ParseSpells()
        {
            List<Spell> spells = new List<Spell>();

            XmlDocument doc = new XmlDocument();
            doc.Load(spellFile);

            foreach (XmlNode node in doc.DocumentElement.ChildNodes)
            {
                Spell spell = new Spell();

                foreach (XmlNode value in node.ChildNodes)
                {
                    switch (value.Name)
                    {
                        case "ID":
                            spell.ID = byte.Parse(value.InnerText);
                            break;
                        case "Name":
                            spell.Name = value.InnerText;
                            break;
                        case "Words":
                            spell.Words = value.InnerText;
                            break;
                        case "Mana":
                            spell.Mana = ushort.Parse(value.InnerText);
                            break;
                        case "ProduceID":
                            spell.ProduceID = ushort.Parse(value.InnerText);
                            break;
                        case "ProduceAmount":
                            spell.ProduceAmount = byte.Parse(value.InnerText);
                            break;
                        case "LevelCast":
                            spell.LvlCast = byte.Parse(value.InnerText);
                            break;
                        case "LevelUse":
                            spell.LvlUse = byte.Parse(value.InnerText);
                            break;
                        case "Price":
                            spell.Price = ushort.Parse(value.InnerText);
                            break;
                        case "Vocation":
                            foreach (char c in value.InnerText)
                            {
                                switch (c)
                                {
                                    case 'K':
                                        spell.VocKnight = true;
                                        break;
                                    case 'P':
                                        spell.VocPaladin = true;
                                        break;
                                    case 'S':
                                        spell.VocSorcerer = true;
                                        break;
                                    case 'D':
                                        spell.VocDruid = true;
                                        break;
                                }
                            }
                            break;
                        case "Group":
                            switch (value.InnerText)
                            {
                                case "Healing":
                                    spell.Group = 0;
                                    break;
                                case "Support":
                                    spell.Group = 1;
                                    break;
                                case "Attack":
                                    spell.Group = 2;
                                    break;
                            }
                            break;
                        case "Type":
                            switch (value.InnerText)
                            {
                                case "Instant":
                                    spell.Type = 0;
                                    break;
                                case "Rune":
                                    spell.Type = 1;
                                    break;
                            }
                            break;
                        case "Premium":
                            spell.Premium = true;
                            break;
                    }

                }
                spells.Add(spell);
            }

            var sorted = spells.OrderBy(s => s.ID).ToList();


            return spells;

        }

        #endregion

        #region NPC

        // NPC
        public List<NPC> ParseNPC()
        {
            List<NPC> npcList = new List<NPC>();
            string[] files = Directory.GetFiles(npcFolder, "*.txt");

            foreach (var filePath in files)
            {
                NPC npc = new NPC();
                npc.Filename = Path.GetFileName(filePath);

                List<Tuple<string, int>> lines = new List<Tuple<string, int>>(); // For storing line + topic so we can retroactively associate lines with sell/buy/spell topics

                int buyTopic, sellTopic, spellTopic;
                buyTopic = sellTopic = spellTopic = -1;

                // Read and preprocess
                using (System.IO.StreamReader file = new System.IO.StreamReader(filePath))
                {
                    string dirtyLine;

                    while ((dirtyLine = file.ReadLine()) != null)
                    {
                        if (!string.IsNullOrEmpty(dirtyLine))
                        {
                            string cleanLine = System.Text.RegularExpressions.Regex.Replace(dirtyLine, @"\s+", " ");

                            int topicIndex = cleanLine.IndexOf("Topic=");
                            int topic = -1;

                            if (topicIndex != -1)
                            {

                                bool success = false;

                                success = Int32.TryParse(GetBetweenChars(cleanLine.Substring(topicIndex + 5), '=', ','), out topic);

                                if (!success)
                                    success = Int32.TryParse(GetBetweenChars(cleanLine.Substring(topicIndex + 5), '=', ' '), out topic);

                                //Console.Write(topic);


                                if (cleanLine.Contains("DeleteMoney"))
                                {
                                    if (cleanLine.Contains("TeachSpell"))
                                        spellTopic = topic;
                                    else
                                        buyTopic = topic;
                                }
                                else if (cleanLine.Contains("CreateMoney"))
                                {
                                    sellTopic = topic;
                                }
                            }

                            if (!npc.Vendor)
                                if (cleanLine.Contains("Price=")) npc.Vendor = true;

                            lines.Add(new Tuple<string, int>(cleanLine, topic));
                        }
                    }
                }

                // Parse (this is garbage spaghetti and inefficient but it works and is fast enough so I don't care)
                foreach (Tuple<string, int> tuple in lines)
                {

                    string line = tuple.Item1;

                    string[] split = line.Split(' ');

                    if (!npc.Vendor)
                        if (line.Contains("Price=")) npc.Vendor = true;

                    if (split[0] == "Name") npc.Name = GetBetweenChars(line, '"', '"');
                    else if (split[0] == "Home")
                    {
                        var loc = GetBetweenChars(line, '[', ']').Split(',');
                        npc.Position = new Point3D(int.Parse(loc[0]), int.Parse(loc[1]), int.Parse(loc[2]));

                    }
                    else if (npc.Vendor)
                    {
                        if (line.Contains("Price="))
                        {

                            NPC.Transaction transaction = new NPC.Transaction();
                            transaction.Type = NPC.TransactionType.Buy;
                            transaction.ItemID = -1;
                            transaction.Price = -1;

                            string itemName = GetBetweenChars(line, '"', '"');

                            int typeIndex = line.IndexOf("Type=");
                            string itemID = GetBetweenChars(line.Substring(typeIndex + 4), '=', ',');

                            int priceIndex = line.IndexOf("Price=");
                            string price = GetBetweenChars(line.Substring(priceIndex + 5), '=', ',');

                            int dataIndex = line.IndexOf("Data=");

                            if (dataIndex != -1)
                            {
                                string data = GetBetweenChars(line.Substring(dataIndex + 4), '=', ',');
                                transaction.Data = short.Parse(data);
                            }

                            // Console.WriteLine(filePath);
                            // Console.WriteLine(line);

                            if (typeIndex != -1) transaction.ItemID = int.Parse(itemID);

                            var priceSplit = price.Split('*');


                            int leftTerm, rightTerm;
                            leftTerm = rightTerm = -1;

                            bool success1, success2;
                            success1 = success2 = false;

                            success1 = Int32.TryParse(priceSplit[0], out leftTerm);
                            if (!success1 && priceSplit.Length == 2)
                                success2 = Int32.TryParse(priceSplit[1], out rightTerm);

                            if (success1) transaction.Price = leftTerm;
                            else if (success2) transaction.Price = rightTerm;

                            if (tuple.Item2 == buyTopic)
                                transaction.Type = NPC.TransactionType.Buy;
                            else if (tuple.Item2 == sellTopic)
                                transaction.Type = NPC.TransactionType.Sell;
                            else if (tuple.Item2 == spellTopic)
                                transaction.Type = NPC.TransactionType.Spell;

                            if (transaction.ItemID != -1)
                                npc.transactions.Add(transaction);
                        }
                    }
                }

                // Post-processing

                int index = npc.transactions.FindIndex(t => t.Type == NPC.TransactionType.Buy || t.Type == NPC.TransactionType.Sell);
                if (index != -1) npc.Vendor = true; // Probably redundant but might as well check since my parsing is shit
                else npc.Vendor = false;

                index = npc.transactions.FindIndex(t => t.Type == NPC.TransactionType.Spell);
                if (index != -1) npc.IsTeacher = true;


                if (npc.Vendor || npc.IsTeacher)
                {
                    // Clear out duplicates
                    npc.transactions = new HashSet<DataReader.NPC.Transaction>(npc.transactions).ToList();

                }

                npc.Location = npc.GetClosestLocation(locations);

                npcList.Add(npc);

            }


            return npcList;
        }

        public class NPC
        {
            public enum TransactionType
            {
                Buy,
                Sell,
                Spell
            }

            public struct Transaction
            {
                public TransactionType Type;
                public int ItemID;
                public int Price;
                public short Data;
            }

            public List<Transaction> transactions;

            public bool Vendor;
            public bool IsTeacher;

            public string Name;
            public Location Location;
            public Point3D Position;

            public string Filename;

            public NPC()
            {
                transactions = new List<Transaction>();
            }

            public List<Transaction> GetTransactions(TransactionType type)
            {
                return transactions.FindAll(i => i.Type == type);
            }

            public List<Transaction> GetTransactions()
            {
                List<Transaction> list = new List<Transaction>();

                list.AddRange(GetTransactions(TransactionType.Buy));
                list.AddRange(GetTransactions(TransactionType.Sell));
                list.AddRange(GetTransactions(TransactionType.Spell));

                return list;
            }

            public Location GetClosestLocation(List<Location> locations)
            {
                Location closest = locations[0];

                double lowestDistance = distance(this.Position.X, this.Position.Y, closest.Position.X, closest.Position.Y);

                foreach (var loc in locations)
                {
                    var dist = distance(this.Position.X, this.Position.Y, loc.Position.X, loc.Position.Y);
                    if (dist < lowestDistance)
                    {
                        closest = loc;
                        lowestDistance = dist;

                    }
                }


                return closest;
            }


        }
        public class Command
        {

        }
        #endregion

        #region Monster

        public class Monster
        {
            public struct Drop
            {
                public int ItemID;
                public int Amount;
                public int Rate;
            }

            public string Filename;

            public List<Drop> Inventory;
            public List<string> Flags;

            public string Name;
            public string Article;

            public int Experience;
            public int SummonCost;

            public int Hitpoints;
            public int Speed;
            public int Capacity;
            // public int Fistfighting; <-- I don't exactly understand the line to parse for this, might as well leave it out

            public int Attack;
            public int Defense;
            public int Armor;

            public Monster()
            {
                Inventory = new List<Drop>();
                Flags = new List<string>();
            }

        }

        public List<Monster> ParseMonsters()
        {

            List<Monster> monsterList = new List<Monster>();
            string[] files = Directory.GetFiles(monsterFolder, "*.txt");

            foreach (var filePath in files)
            {

                using (System.IO.StreamReader file = new System.IO.StreamReader(filePath))
                {
                    string dirtyLine;
                    bool inBracket = false;

                    List<string> brackets = new List<string>();

                    Monster monster = new Monster();

                    monster.Filename = Path.GetFileName(filePath);

                    while ((dirtyLine = file.ReadLine()) != null)
                    {
                        if (!string.IsNullOrEmpty(dirtyLine))
                        {
                            string cleanLine = System.Text.RegularExpressions.Regex.Replace(dirtyLine, @"\s+", " ");

                            var split = cleanLine.Split(' ');

                            if (cleanLine.Contains('{'))
                            {
                                inBracket = true;
                                brackets.Add("");
                            }

                            if (inBracket)
                                brackets[brackets.Count - 1] += cleanLine;
                            else
                            {
                                switch (split[0])
                                {
                                    case "Name":
                                        monster.Name = CapitalizeString(GetBetweenChars(cleanLine, '"', '"'));
                                        break;
                                    case "Article":
                                        monster.Article = CapitalizeString(GetBetweenChars(cleanLine, '"', '"'));
                                        break;
                                    case "Experience":
                                        monster.Experience = int.Parse(split[2]);
                                        break;
                                    case "Attack":
                                        monster.Attack = int.Parse(split[2]);
                                        break;
                                    case "Defend":
                                        monster.Defense = int.Parse(split[2]);
                                        break;
                                    case "Armor":
                                        monster.Armor = int.Parse(split[2]);
                                        break;
                                    case "SummonCost":
                                        monster.SummonCost = int.Parse(split[2]);
                                        break;
                                }
                            }

                            if (cleanLine.Contains('}'))
                                inBracket = false;
                        }
                    }

                    // Parse brackets
                    foreach (string line in brackets)
                    {
                        var split = line.Split(' ');
                        string bracketName = split[0];

                        var bracket = GetBetweenChars(line, '{', '}');

                        if (bracketName == "Inventory")
                        {

                            foreach (var item in GetParenthesisArray(bracket))
                            {
                                var itemSplit = item.Split(',');

                                Monster.Drop drop;

                                drop.ItemID = int.Parse(itemSplit[0]);
                                drop.Amount = int.Parse(itemSplit[1]);
                                drop.Rate = int.Parse(itemSplit[2]);

                                monster.Inventory.Add(drop);
                            }
                        }
                        else if (bracketName == "Skills")
                        {
                            foreach (var item in GetParenthesisArray(bracket))
                            {
                                var itemSplit = item.Split(',');

                                switch (itemSplit[0])
                                {
                                    case "HitPoints":
                                        monster.Hitpoints = int.Parse(itemSplit[1]);
                                        break;
                                    case "GoStrength":
                                        monster.Speed = int.Parse(itemSplit[1]);
                                        break;
                                    case "CarryStrength":
                                        monster.Capacity = int.Parse(itemSplit[1]);
                                        break;
                                        // case "FistFighting":
                                        //     monster.Fistfighting = int.Parse(itemSplit[0]);
                                        //     break;
                                }
                            }
                        }
                        else if (bracketName == "Flags")
                        {
                            foreach (var flag in bracket.Split(',')) monster.Flags.Add(flag);
                        }

                    }

                    monsterList.Add(monster);

                }
            }

            return monsterList;
        }

        #endregion

        #region Raid

        public class Raid
        {

            public enum RaidType
            {
                ParseFailed,
                BigRaid,
                SmallRaid
            }

            public class RaidSpawn
            {
                public int Delay;
                public Point3D Position;
                public int Spread;
                public int Race;
                public Tuple<int,int> Count;
                public int Lifetime;
                public string Message;
                public List<Monster.Drop> ItemDrops;

                public RaidSpawn()
                {
                    this.ItemDrops = new List<Monster.Drop>();
                    this.Count = new Tuple<int, int>(-1, -1);
                }
            }

            public string Filename;
            public RaidType Type;
            public int Interval;
            public List<RaidSpawn> Spawns;

            public Raid()
            {
                this.Spawns = new List<RaidSpawn>();
            }
        }


        public List<Raid> ParseRaids()
        {
            var raids = new List<Raid>();
            string[] files = Directory.GetFiles(monsterFolder, "*.evt");

            foreach (var filePath in files)
            {
                using (System.IO.StreamReader file = new System.IO.StreamReader(filePath))
                {
                    string dirtyLine;

                    Raid raid = new Raid();
                    Raid.RaidSpawn spawn = null;

                    raid.Filename = Path.GetFileName(filePath);
                    bool inBracket = false;
                    List<string> bracketLines = null;

                    while ((dirtyLine = file.ReadLine()) != null)
                    {
                        if (!string.IsNullOrEmpty(dirtyLine))
                        {
                            string cleanLine = System.Text.RegularExpressions.Regex.Replace(dirtyLine, @"\s+", "");

                            if (cleanLine[0] != '#')
                            {
                                var split = cleanLine.Split('=');

                                switch(split[0])
                                {
                                    case "Type":
                                        Raid.RaidType type;
                                        bool typeParse = Enum.TryParse(split[1], out type);
                                            raid.Type = type;
                                        break;
                                    case "Interval":
                                        int interval = 0;
                                        int.TryParse(split[1], out interval);
                                            raid.Interval = interval;
                                        break;
                                    case "Delay":
                                        if (spawn != null)
                                            raid.Spawns.Add(spawn);

                                        spawn = new Raid.RaidSpawn();
                                        int delay = 0;
                                        int.TryParse(split[1], out delay);
                                        spawn.Delay = delay;
                                        break;
                                    case "Position":
                                        var posSplit = split[1].Substring(1, split[1].Length - 1).Split(',');
                                        int posX, posY, posZ;
                                        posX = posY = posZ = -1;
                                        int.TryParse(posSplit[0], out posX);
                                        int.TryParse(posSplit[1], out posY);
                                        int.TryParse(posSplit[2], out posZ);
                                        spawn.Position = new Point3D(posX, posY, posZ);
                                        break;
                                    case "Spread":
                                        int spread = 0;
                                        int.TryParse(split[1], out spread);
                                        spawn.Spread = spread;
                                        break;
                                    case "Race":
                                        int race = 0;
                                        int.TryParse(split[1], out race);
                                        spawn.Race = race;
                                        break;
                                    case "Count":
                                        var countSplit = split[1].Substring(1, split[1].Length - 1).Split(',');
                                        int countMin, countMax;
                                        countMin = countMax = -1;
                                        int.TryParse(countSplit[0], out countMin);
                                        int.TryParse(countSplit[1], out countMax);
                                        spawn.Count = new Tuple<int, int>(countMin, countMax);
                                        break;
                                    case "Message":
                                        spawn.Message = GetBetweenChars(dirtyLine, '"', '"');
                                        break;
                                    case "Lifetime":
                                        int lifetime = 0;
                                        int.TryParse(split[1], out lifetime);
                                        spawn.Lifetime = lifetime;
                                        break;
                                    case "Inventory":
                                        inBracket = true;
                                        bracketLines = new List<string>();
                                        break;
                                }

                                if (inBracket)
                                {
                                    bracketLines.Add(cleanLine);
                                    if (cleanLine.Contains('}')) {
                                        inBracket = false;
                                        foreach (var a in bracketLines)
                                        {
                                            var dropData = GetBetweenChars(a, '(', ')').Split(',');

                                            int itemID, amount, rate;
                                            itemID = amount = rate = 0;

                                            int.TryParse(dropData[0], out itemID);
                                            int.TryParse(dropData[1], out amount);
                                            int.TryParse(dropData[2], out rate);

                                            Monster.Drop drop = new Monster.Drop { ItemID = itemID, Amount = amount, Rate = rate };

                                            spawn.ItemDrops.Add(drop);
                                        }
                                    }
                                }

                            }
                        }
                    }
                    raids.Add(raid);
                }
            }
            
            return raids;

        }

        #endregion

        #region Utility

        public string GetBetweenChars(string input, char start, char end)
        {
            string between = "";
            bool began = false;

            foreach (char c in input)
            {
                if (began)
                {
                    if (c == end) break;
                    between += c;
                }
                if (c == start) began = true;
            }


            return between;
        }
        private List<string> GetParenthesisArray(string input)
        {
            List<string> parentheses = new List<string>(); 
            string pString = "";

            foreach (var c in input)
            {
                if (c == '(')
                {
                    pString = "";
                }
                else if (c == ')')
                {
                    parentheses.Add(pString); 
                }
                else if (c != ' ') pString += c;
            }  

            return parentheses;
        }

        static double distance(int x1, int y1, int x2, int y2)
        {
            // Calculating distance 
            return Math.Sqrt(Math.Pow(x2 - x1, 2) +
                          Math.Pow(y2 - y1, 2) * 1.0);
        }

        #endregion


    }
}
